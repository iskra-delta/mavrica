ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 1.
Hexadecimal [24-Bits]



                                      1 		;; args.s
                                      2         ;; 
                                      3         ;; program arguments
                                      4 		;;
                                      5         ;; MIT License (see: LICENSE)
                                      6         ;; copyright (c) 2022 tomaz stih
                                      7         ;;
                                      8 		;; 22.03.2022    tstih
                                      9         .module args
                                     10 
                                     11 
                                     12         .globl  pargs
                                     13         .globl  argc
                                     14         .globl  argv
                                     15 
                                     16 
                                     17         .area   _CODE
                                     18         ;; parse command line in CP/M
      000000                         19 pargs::
      000000 21 80 00         [10]   20         ld      hl,#0x80                ; args start
                                     21         ;; argv[0] is NULL
      000003 11 02 00         [10]   22         ld      de,#argv                ; argv pointers
      000006 AF               [ 4]   23         xor     a
      000007 12               [ 7]   24         ld      (de),a
      000008 13               [ 6]   25         inc     de
      000009 12               [ 7]   26         ld      (de),a
      00000A 13               [ 6]   27         inc     de                      ; dl points to first "real" argv
                                     28         ;; argc=1 (default)
      00000B AF               [ 4]   29         xor     a
      00000C 32 01 00         [13]   30         ld      (argc+1),a
      00000F 3C               [ 4]   31         inc     a
      000010 32 00 00         [13]   32         ld      (argc),a
                                     33         ;; let de point to first char which is length
      000013 7E               [ 7]   34         ld      a,(hl)                  ; get number of bytes to b
      000014 47               [ 4]   35         ld      b,a                     ; b is counter
      000015 23               [ 6]   36         inc     hl                      ; hl points to first char
      000016 7E               [ 7]   37         ld      a,(hl)                  ; check it
      000017 FE 20            [ 7]   38         cp      #' '                    ; skip initial space...
      000019 20 01            [12]   39         jr      nz,pargs_go 
      00001B 23               [ 6]   40         inc     hl                      ; next char...
      00001C                         41 pargs_go:
      00001C E5               [11]   42         push    hl                      ; "remember" start of current arg
      00001D                         43 pargs_loop:
                                     44         ;; now iterate
      00001D 7E               [ 7]   45         ld      a,(hl)
                                     46         ;; is it end of arguments?
      00001E FE 00            [ 7]   47         cp      #0                      
      000020 28 07            [12]   48         jr      z,pargs_end
                                     49         ;; is it end of current argument?
      000022 FE 20            [ 7]   50         cp      #' '                    
      000024 28 1A            [12]   51         jr      z,pargs_next
                                     52         ;; if we're here it's a simple char...
      000026 23               [ 6]   53         inc     hl
      000027 10 F4            [13]   54         djnz    pargs_loop
                                     55         ;; if no more looping we're done
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (Zilog Z80 / Hitachi HD64180 / ZX-Next / eZ80), page 2.
Hexadecimal [24-Bits]



      000029                         56 pargs_end:
                                     57         ;; get a at start of arg
      000029 D9               [ 4]   58         exx
      00002A E1               [10]   59         pop     hl
      00002B 7E               [ 7]   60         ld      a,(hl)
      00002C E5               [11]   61         push    hl
      00002D D9               [ 4]   62         exx
                                     63         ;; is it 0?
      00002E B7               [ 4]   64         or      a
      00002F 28 29            [12]   65         jr      z,pargs_noarg
                                     66         ;; else store argument
      000031 E1               [10]   67         pop     hl                      ; get arg
      000032 EB               [ 4]   68         ex      de,hl
      000033 73               [ 7]   69         ld      (hl),e
      000034 23               [ 6]   70         inc     hl
      000035 72               [ 7]   71         ld      (hl),d
      000036 EB               [ 4]   72         ex      de,hl
                                     73         ;; inc. argc
      000037 3A 00 00         [13]   74         ld      a,(argc)
      00003A 3C               [ 4]   75         inc     a
      00003B 32 00 00         [13]   76         ld      (argc),a
                                     77         ;; and return
      00003E 18 1B            [12]   78         jr      pargs_done   
      000040                         79 pargs_next:
      000040 AF               [ 4]   80         xor     a                       ; zero terminate
      000041 77               [ 7]   81         ld      (hl),a                  ; the argument
      000042 23               [ 6]   82         inc     hl                      ; next arg
      000043 D5               [11]   83         push    de                      ; current arg to stack
      000044 D9               [ 4]   84         exx
      000045 D1               [10]   85         pop     de                      ; get current arg from stack
      000046 E1               [10]   86         pop     hl                      ; get start of arg from stack
      000047 EB               [ 4]   87         ex      de,hl
      000048 73               [ 7]   88         ld      (hl),e                  ; write arg to arg list
      000049 23               [ 6]   89         inc     hl
      00004A 72               [ 7]   90         ld      (hl),d
      00004B 23               [ 6]   91         inc     hl
      00004C EB               [ 4]   92         ex      de,hl
      00004D D5               [11]   93         push    de                      ; store arg list new end
      00004E D9               [ 4]   94         exx
      00004F D1               [10]   95         pop     de                      ; get arg list 
      000050 E5               [11]   96         push    hl                      ; next arg to stack
      000051 3A 00 00         [13]   97         ld      a,(argc)                ; increase argc
      000054 3C               [ 4]   98         inc     a
      000055 32 00 00         [13]   99         ld      (argc),a
      000058 10 C3            [13]  100         djnz    pargs_loop
      00005A                        101 pargs_noarg:
      00005A E1               [10]  102         pop     hl                      ; clean stack
      00005B                        103 pargs_done:
      00005B C9               [10]  104         ret
                                    105 
                                    106         .area   _DATA
      000000                        107 argc::
      000000 01 00                  108         .dw 1                           ; default argc is 1 (filename!)
      000002                        109 argv::
      000002                        110         .ds 16                          ; max 8 argv arguments
